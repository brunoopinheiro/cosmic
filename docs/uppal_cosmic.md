# Using COSMIC with UPPAAL for Finite State Machine Modeling
COSMIC was initially developed to support the modeling and analysis of Finite State Machines (FSMs) using the UPPAAL tool. This document provides an overview of how to utilize COSMIC in conjunction with UPPAAL for FSM modeling.

## General Notes on Syntax
When modeling FSMs in UPPAAL using COSMIC, it is important to adhere to specific syntax conventions to ensure compatibility and correctness. Not all UPPAAL constructs are supported by COSMIC, so users should refer to the COSMIC documentation for a comprehensive list of supported features.

### Naming the Machine
COSMIC will utilize the name of each of your defined UPPAAL templates as the name of the corresponding Machine and Machine Model class in Python.

### Guards
In COSMIC, guards are used to define conditions that must be met for transitions to occur. When specifying guards, ensure that they are expressed in a way that COSMIC can interpret correctly.
Preferably, you should declare your guards as boolean functions in the `Guards` section of your UPPAAL model.
```uppaal
correctPIN()
```
This means that the result of the function `correctPIN()` will be evaluated to determine if the transition can take place.

Alternatively, you could combine multiple conditions using logical operators:
```uppaal
correctPIN() && !maximumAttempts()
```
This indicates that the transition can occur if `correctPIN()` is true and `maximumAttempts()` is false.

You can also use simple boolean expressions directly in the guard:
```uppaal
attempts == 0
```
and COSMIC will translate those to python functions.

The above examples, when generated by COSMIC, will result in the following Python functions in the Machine Model:

```python
class GateModel:
    # Auto generated code. Please, adjust!

    def maximum_attempts(self):
        raise NotImplementedError('Implement This Model Behavior.')

    def correct_p_i_n(self):
        raise NotImplementedError('Implement This Model Behavior.')

    def attempts_eq_zero(self):
        raise NotImplementedError('Implement This Model Behavior.')
```

When you declare a guard with a `not` operator, COSMIC will interpret this as a `unless` condition in the generated python code. At the `transitions` it will look like this:

```python
{
    'trigger': 'enter_p_i_n_to_unlocked',
    'source': 'enter_p_i_n',
    'dest': 'unlocked',
    'conditions': ['correct_p_i_n'],
    'unless': ['maximum_attempts'],
    'after': ['reset_attempts'],
},
```

### Updates
Updates in COSMIC are used to define actions that occur when a transition is taken. They can be declared either as void functions, or as assignments to variables.
For example, you can define an update as a function:

```uppaal
resetAttempts()
```
This indicates that the function `resetAttempts()` will be called when the transition occurs.

Alternatively, you can use assignments to update variable values:
```uppaal
attempts++
```
This indicates that the variable `attempts` will be incremented by one when the transition occurs.

The above examples, when generated by COSMIC, will result in the following Python functions in the Machine Model:

```python
class GateModel:
    # Auto generated code. Please, adjust!

    def reset_attempts(self):
        raise NotImplementedError('Implement This Model Behavior.')

    def attempts_increment(self):
        raise NotImplementedError('Implement This Model Behavior.')
```

